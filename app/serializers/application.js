import {isEmpty} from '@ember/utils';
import {assign} from '@ember/polyfills';
import Service, { inject as service } from '@ember/service';
import RESTSerializer from '@ember-data/serializer/rest';
import { pluralize, singularize } from 'ember-inflector';
import { camelize } from '@ember/string';

export default class ApplicationSerializer extends RESTSerializer {
	@service store;
	/**
	 * change payload format sent to the backend
	 from
	 	{"model-name": {property1: value, property2: value}}
	 to
	 	{property1: value, property2: value}
	 */
	serializeIntoHash(data, type, record, options) {
		assign(data, this.serialize(record, options));
	}

	/**
	 * handles empty response from backend and avoids the Ember assertion "The response to store.query is expected to be an array but it was a single record"
	 * because Ember RESTSerializer not following REST standards
	 *
	 * takes cares of 2 responses coming from the backend
	 * - empty responses (like 204 HTTP_NO_CONTENT), http errors do no get to this stage
	 * - responses with {"data": []} generated by the JMS Serializer in the backend
	 */
	normalizeResponse(store, primaryModelClass, payload, id, requestType) {
		if ( isEmpty(payload) || ("data" in payload && isEmpty(payload.data) ) ) {
			// the internal store._push() expects an empty array for it to be handled as an empty response
			// the default implementation sets data:null, which triggers an assertion
			return { data: [] } ;
		}
		const ret = super.normalizeResponse(store, primaryModelClass, payload, id, requestType) ;
		return ret;
	}
}

